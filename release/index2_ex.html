<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Buildings Visualization</title>
    <script src="js/d3.v7.min.js"></script>
    <link href="https://fonts.googleapis.com/css?family=Cormorant+Garamond:400,700&display=swap&subset=vietnamese" rel="stylesheet">
    <style>
        .tooltip {
            position: absolute;
            background: rgba(255, 255, 255, 0.97);
            border: 1.2px solid #e5e7eb;
            border-radius: 10px;
            padding: 12px 18px 12px 18px;
            pointer-events: none;
            /* font-family: 'Cormorant Garamond', Arial, sans-serif; */
            font-size: 15px;
            color: #273046;
            box-shadow: 0 4px 24px rgba(39,48,70,0.10), 0 1.5px 8px rgba(39,48,70,0.06);
            min-width: 120px;
            line-height: 1.7;
            transition: opacity 0.18s;
            z-index: 10;
        }

        /* åŸç‚¹æ ‡è®° */
        .origin-point {
            filter: drop-shadow(0 0 2px rgba(0,0,0,0.5));
        }
    </style>
</head>
<body>
   

        

    <script type="module">
    // import * as d3 from "./js/d3.v7.min.js";
    
        // è®¾ç½®å›¾è¡¨å°ºå¯¸å’Œè¾¹è·
        const margin = { top: 40, right: 30, bottom: 40, left: 50 };
        const width = 800 - margin.left - margin.right;
        const height = 900 - margin.top - margin.bottom;
        
        // åˆ›å»ºSVGå®¹å™¨
        const svg = d3.select("body").append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
        .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);
        
        // æ·»åŠ æ ‡é¢˜
        svg.append("text")
            .attr("x", width / 2)
            .attr("y", -margin.top + 30)
            .attr("text-anchor", "middle")
            .style("font-size", "16px")
            .style("font-weight", "bold")


        svg.append("defs").html(`
            <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="8" result="coloredBlur"/>
            <feMerge>
                <feMergeNode in="coloredBlur"/>
                <feMergeNode in="SourceGraphic"/>
            </feMerge>
            </filter>
        `);
        
        // é»„é‡‘èºæ—‹å‚æ•°
        const a = 15; // åˆå§‹åŠå¾„
        const b = 0.306349; // ln(phi)/pi, phi=é»„é‡‘æ¯”ä¾‹
        const centerX = width / 2;
        const centerY = height / 2;


        // .domain(d3.extent(data, d => d.hot_sum).reverse());

        // const color = d3.scaleSequential(d3.interpolateRdYlBu)
            // .domain(d3.extent(data, d => d.hot_sum).reverse());

        // è¯»å–æ•°æ®
        d3.csv("data/2.csv").then(data => {
            // è½¬æ¢æ•°æ®ç±»å‹
            data.forEach(d => {
                d.count = +d.count;
                d.hot_sum = +d.hot_sum;
                d.Year = d.Year || d.year || d.YEAR; // å…¼å®¹ä¸åŒè¡¨å¤´
            });
        
            // è®¡ç®—é¢œè‰²åŸŸ
            // color.domain(d3.extent(data, d => d.hot_sum));
             // é¢œè‰²æ¯”ä¾‹å°º
            // const color = d3.scaleSequential(d3.interpolateYlOrRd);
            const minHot = d3.min(data, d => d.hot_sum);
            const maxHot = d3.max(data, d => d.hot_sum);

            const color = d3.scaleSequential(d3.interpolateRdYlBu).domain(d3.extent(data, d => d.hot_sum)); // åè½¬ï¼Œé«˜å€¼çº¢è‰²

            color.domain(d3.extent(data, d => d.hot_sum).reverse());

        
            // è®¡ç®—æœ€å¤§countç”¨äºç¼©æ”¾åœ†åŠå¾„
            const maxCount = d3.max(data, d => d.count);
            const rScale = d3.scalePow().exponent(2)
            .domain([0, maxCount])
            .range([12, 50]);

        
            // // é»„é‡‘èºæ—‹æŠ˜ç‚¹
            // const n = data.length;
            // const thetaStep = 2 * Math.PI / (n + 1); // å‡åŒ€åˆ†å¸ƒ
            // const points = data.map((d, i) => {
            //     const theta = i * thetaStep * 2.1; // 2.5å¯è°ƒèŠ‚èºæ—‹æ¾ç´§
            //     // const r = a * Math.exp(b * theta);
            //     let r = a * Math.exp(b * theta);
            //     if (+d.Year < 2012) {
            //         r = r * 1.2; // 2015å¹´ä¹‹åçš„ç‚¹æ›´é è¿‘ä¸­å¿ƒ
            //     } 
            //     if (+d.Year > 2015) {
            //         r = r * 0.9; // 2015å¹´ä¹‹åçš„ç‚¹æ›´é è¿‘ä¸­å¿ƒ
            //     } 
            //     if (+d.Year >=2018) {
            //         r = r * 0.88; // 2010å¹´ä¹‹å‰çš„ç‚¹æ›´è¿œç¦»ä¸­å¿ƒ
            //     }   
            //     console.log('r',+d.Year, r);

            //     return {
            //         x: centerX + r * Math.cos(theta),
            //         y: centerY + r * Math.sin(theta),
            //         d: d
            //     };
            // });

            // ===== é»„é‡‘èºæ—‹å‚æ•° =====
            const a = 15;
            const b = 0.3;
            const centerX = width / 2;
            const centerY = height / 2;
            const n = data.length;
            const spiralSegments = 2000; // è¶Šå¤§è¶Šå¹³æ»‘
            const theta_max = 1.65 * Math.PI * 2;   // æ€»åœˆæ•°ï¼Œè‡ªè¡Œè°ƒèŠ‚
            // åˆ†å¸ƒæ§åˆ¶ï¼š<1 å†…ç¨€å¤–å¯†ï¼Œ=1 å‡åŒ€ï¼Œ>1 å¤–ç¨€å†…å¯†
            function customDistrib(f) { return Math.pow(f, 0.62); }

            // ===== 1. é«˜å¯†åº¦é‡‡æ ·æ ‡å‡†é»„é‡‘èºæ—‹è½¨è¿¹ spiralSamples & å¼§é•¿ spiralArcLength =====
            const spiralSamples = [];
            const spiralArcLength = [0];
            let totalLength = 0;
            let prev = null;
            for (let i = 0; i < spiralSegments; i++) {
                const t = i / (spiralSegments - 1);
                const theta = theta_max * t;
                const r = a * Math.exp(b * theta);
                const x = centerX + r * Math.cos(theta);
                const y = centerY + r * Math.sin(theta);
                if (prev) totalLength += Math.hypot(x - prev.x, y - prev.y);
                spiralSamples.push({theta, r, t, x, y});
                spiralArcLength.push(totalLength);
                prev = {x, y};
            }

            // ===== 2. èºæ—‹æ›²çº¿åªç”¨ spiralSamples ç”»ï¼Œä¿è¯100%æ ‡å‡† =====
            svg.append("path")
                .datum(spiralSamples)
                .attr("fill", "none")
                .attr("stroke", "#aaa")
                .attr("stroke-width", 2)
                .attr("d", d3.line()
                    .x(d => d.x)
                    .y(d => d.y)
                    .curve(d3.curveCardinal)
                );
            

            // ===== 3. åœ†ç‚¹åˆ†å¸ƒä» spiralSamples å–ç‚¹ï¼Œä¿è¯åœ†å¿ƒä¸¥æ ¼åœ¨çº¿ä¸Š =====
            const points = [];
            for (let i = 0; i < n; i++) {
                const f = i / (n - 1);
                const targetLen = totalLength * customDistrib(f); // éå‡åŒ€åˆ†å¸ƒç›®æ ‡å¼§é•¿
                // äºŒåˆ†æŸ¥æ‰¾ spiralArcLength ä¸­æœ€è¿‘çš„ç´¢å¼•
                let low = 0, high = spiralArcLength.length - 1;
                while (low < high) {
                    let mid = Math.floor((low + high) / 2);
                    if (spiralArcLength[mid] < targetLen) low = mid + 1;
                    else high = mid;
                }
                const idx = Math.min(low, spiralSamples.length - 1);
                const s = spiralSamples[idx];

                // ===== å¹´ä»½å¾®è°ƒ: é‡æ–°æ ¹æ®é‡‡æ ·ç‚¹thetaè®¡ç®—æ–°rï¼Œx, y =====
                let r = s.r;
                let x=s.x;
                let y=s.y;
                const d = data[i];
                // if (+d.Year < 2012) r = r * 1.2;
                // if (+d.Year > 2015) r = r * 0.9;
                // if (+d.Year >= 2018) r = r * 0.88;
                // const x = centerX + r * Math.cos(s.theta);
                // const y = centerY + r * Math.sin(s.theta);

                // ===== è®°å½•ä¸‹æ¥ï¼Œåç»­å…¨éƒ¨ç”¨ points =====
                points.push({x, y, d});
            }

            svg.selectAll("circle")
            .data(points)
            .join("circle")
            .attr("cx", d => d.x)
            .attr("cy", d => d.y)
            .attr("r", d => rScale(d.d.count) * 2.0)
            .attr("fill", (d, i) => `url(#${getGradientId(i)})`)
            .attr("filter", "url(#glow)");

            // svg.append("path")
            // .datum(points)
            // .attr("fill", "none")
            // .attr("stroke", "#aaa")
            // .attr("stroke-width", 2)
            // .attr("d", d3.line()
            //     .x(d => d.x)
            //     .y(d => d.y)
            //     .curve(d3.curveCardinal)
            // );



         // ç”Ÿæˆå”¯ä¸€æ¸å˜id
            function getGradientId(i) {
                return `radial-gradient-${i}`;
            }

            // å®šä¹‰æ¸å˜
            points.forEach((pt, i) => {
                const grad = svg.append("radialGradient")
                    .attr("id", getGradientId(i))
                    .attr("cx", "50%").attr("cy", "50%").attr("r", "55%");
                grad.append("stop")
                    .attr("offset", "0%")
                    .attr("stop-color", color(pt.d.hot_sum))
                    .attr("stop-opacity", 1);
                grad.append("stop")
                    .attr("offset", "80%")
                    .attr("stop-color", "#fff")
                    .attr("stop-opacity", 0.1);
                grad.append("stop")
                    .attr("offset", "100%")
                    .attr("stop-color", "#fff")
                    // .attr("stop-color", color(pt.d.hot_sum))
                    .attr("stop-opacity", 0);
            });

            // points.forEach((pt, i) => {
            //     const beams = 50; // å…‰æŸæ•°
            //     const R = rScale(pt.d.count) * 1.1;
            //     for (let j = 0; j < beams; j++) {
            //         const angle = (2 * Math.PI / beams) * j;
            //         svg.append("line")
            //             .attr("x1", pt.x)
            //             .attr("y1", pt.y)
            //             .attr("x2", pt.x + Math.cos(angle) * R * 1.3)
            //             .attr("y2", pt.y + Math.sin(angle) * R * 1.3)
            //             .attr("stroke", color(pt.d.hot_sum))
            //             .attr("stroke-width", 2)
            //             .attr("stroke-opacity", 0.7)
            //             .lower();
            //     }
            // });

            const beams = 50;
            const allBeams = [];
            points.forEach((pt, i) => {
                const R = rScale(pt.d.count) * 1.1;
                for (let j = 0; j < beams; j++) {
                    const angle = (2 * Math.PI / beams) * j;
                    allBeams.push({
                        x1: pt.x,
                        y1: pt.y,
                        x2: pt.x + Math.cos(angle) * R * 1.3,
                        y2: pt.y + Math.sin(angle) * R * 1.3,
                        color: color(pt.d.hot_sum),
                        ptIndex: i
                    });
                }
            });

            svg.selectAll(".beam-line")
                .data(allBeams)
                .join("line")
                .attr("class", "beam-line")
                .attr("x1", d => d.x1)
                .attr("y1", d => d.y1)
                .attr("x2", d => d.x1)  // èµ·å§‹æ—¶ç»ˆç‚¹é‡åˆ
                .attr("y2", d => d.y1)
                .attr("stroke", d => d.color)
                .attr("stroke-width", 2)
                .attr("stroke-opacity", 0.7)
                .lower()
                .transition()
                .delay(d => d.ptIndex * 80)   // è·Ÿéšåœ†çš„ delay
                .duration(900)
                .ease(d3.easeCubicOut)
                .attr("x2", d => d.x2)
                .attr("y2", d => d.y2);


                
            // // ç”»åœ†ç‚¹
            // svg.selectAll("circle")
            //     .data(points)
            //     .join("circle")
            //     .attr("cx", d => d.x)
            //     .attr("cy", d => d.y)
            //     // .attr("r", d => rScale(d.d.count))
            //     // .attr("fill", d => color(d.d.hot_sum))
            //     .attr("r", d => rScale(d.d.count) * 2.0)
            //     .attr("fill", (d, i) => `url(#${getGradientId(i)})`)
            //     .attr("filter", "url(#glow)");
            //     // .attr("stroke", "#333")
            //     // .attr("stroke-width", 1.2);

            svg.selectAll("circle")
                .data(points)
                .join("circle")
                .attr("cx", d => d.x)
                .attr("cy", d => d.y)
                .attr("r", 0) // èµ·å§‹åŠå¾„ä¸º 0
                .attr("fill", (d, i) => `url(#${getGradientId(i)})`)
                .attr("filter", "url(#glow)")
                .transition()
                .delay((d, i) => i * 80)       // ä¾æ¬¡å‡ºç°ï¼Œi è¶Šå¤§å»¶è¿Ÿè¶Šé•¿
                .duration(900)                 // æ¯ä¸ªåœ†çš„åŠ¨ç”»æ—¶é•¿
                .ease(d3.easeCubicOut)         // åŠ¨ç”»ç¼“åŠ¨
                .attr("r", d => rScale(d.d.count) * 2.0); // ç›®æ ‡åŠå¾„

        
            // å¹´ä»½æ ‡ç­¾
            svg.selectAll("text.year")
                .data(points)
                .join("text")
                .attr("class", "year")
                // .attr("x", d => d.x)
                // .attr("y", d => d.y - rScale(d.d.count) - 6)
                .attr("x", d => {
                    // åœ†å¿ƒåˆ°ç‚¹çš„æ–¹å‘å‘é‡
                    const dx = d.x - centerX;
                    const dy = d.y - centerY;
                    const len = Math.sqrt(dx*dx + dy*dy);
                    // å»¶é•¿è·ç¦»ï¼šåœ†åŠå¾„+é¢å¤–è·ç¦»
                    const r = rScale(d.d.count) * 2.5;
                    const extra = 13; // ä½ å¯ä»¥è°ƒå¤§è®©æ ‡ç­¾æ›´è¿œ
                    return centerX + (dx / len) * (len + r + extra);
                })
                .attr("y", d => {
                    const dx = d.x - centerX;
                    const dy = d.y - centerY;
                    const len = Math.sqrt(dx*dx + dy*dy);
                    const r = rScale(d.d.count) * 2.5;
                    const extra = .1;
                    return centerY + (dy / len) * (len + r + extra);
                })
                .attr("text-anchor", "middle")
                .attr("font-family", "Cormorant Garamond, vietnamese")
                .attr("font-size", "16px")
                .attr("fill", "#273046")
                .text(d => d.d.Year);
        
            // å¯é€‰ï¼štooltip
            const tooltip = d3.select("body").append("div")
                .attr("class", "tooltip")
                .style("opacity", 0);
        
            svg.selectAll("circle")
                .on("mouseover", (event, d) => {
                    tooltip.transition().duration(200).style("opacity", .9);
                    tooltip.html(`
                        <div>
                            <div style="font-weight:bold;font-size:22px;letter-spacing:0.5px;margin-bottom:4px;">
                                ğŸ“…${d.d.Year}
                            </div>
                            <div>æ•°é‡ï¼š
                                <span style="font-weight:bold">${d.d.count}</span>
                            </div>
                            <div>çƒ­åº¦ï¼š
                                <span style="font-weight:bold">${d.d.hot_sum}</span>
                            </div>
                        </div>
                    `)

                    .style("left", (event.pageX + 10) + "px")
                    .style("top", (event.pageY - 20) + "px");
                })
                .on("mousemove", (event) => {
                    tooltip.style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 20) + "px");
                })
                .on("mouseout", () => {
                    tooltip.transition().duration(200).style("opacity", 0);
                });
        });
    </script>
</body  >
</html>
